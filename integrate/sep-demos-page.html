<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEP Framework - Interactive Demos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow-x: hidden;
        }

        .hero {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0a 100%);
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 255, 0.03) 2px,
                rgba(255, 255, 255, 0.03) 4px
            );
            animation: scan 8s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        h1 {
            font-size: 4rem;
            font-weight: 300;
            letter-spacing: -2px;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            z-index: 1;
        }

        .subtitle {
            font-size: 1.5rem;
            color: #888;
            margin-bottom: 3rem;
            z-index: 1;
        }

        .demos-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 4rem 2rem;
        }

        .demo-section {
            margin-bottom: 6rem;
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 0.8s ease forwards;
        }

        .demo-section:nth-child(1) { animation-delay: 0.1s; }
        .demo-section:nth-child(2) { animation-delay: 0.2s; }
        .demo-section:nth-child(3) { animation-delay: 0.3s; }
        .demo-section:nth-child(4) { animation-delay: 0.4s; }
        .demo-section:nth-child(5) { animation-delay: 0.5s; }
        .demo-section:nth-child(6) { animation-delay: 0.6s; }
        .demo-section:nth-child(7) { animation-delay: 0.7s; }
        .demo-section:nth-child(8) { animation-delay: 0.8s; }
        .demo-section:nth-child(9) { animation-delay: 0.9s; }
        .demo-section:nth-child(10) { animation-delay: 1.0s; }
        .demo-section:nth-child(11) { animation-delay: 1.1s; }
        .demo-section:nth-child(12) { animation-delay: 1.2s; }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .demo-header {
            display: flex;
            align-items: center;
            margin-bottom: 2rem;
            position: relative;
        }

        .demo-number {
            font-size: 5rem;
            font-weight: 900;
            color: #1a1a2e;
            margin-right: 2rem;
            line-height: 1;
        }

        .demo-title {
            flex: 1;
        }

        .demo-title h2 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .demo-title p {
            color: #888;
            font-size: 1.1rem;
        }

        .demo-canvas {
            background: #0f0f0f;
            border-radius: 20px;
            padding: 2rem;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            cursor: crosshair;
        }

        .controls {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 50px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: left 0.5s ease;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
        }

        input[type="range"] {
            width: 150px;
            height: 5px;
            background: #333;
            outline: none;
            border-radius: 5px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1.5rem;
            margin-top: 1rem;
            font-family: 'Courier New', monospace;
        }

        .quantum-glow {
            position: absolute;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.3) 0%, transparent 70%);
            pointer-events: none;
            filter: blur(40px);
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(30px, -30px) scale(1.1); }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="hero">
        <div class="quantum-glow" style="top: 10%; left: 10%;"></div>
        <div class="quantum-glow" style="bottom: 10%; right: 10%;"></div>
        <h1>SEP Framework</h1>
        <p class="subtitle">Quantum-Inspired Computational Demonstrations</p>
    </div>

    <div class="demos-container">
        <!-- Scene 1: Wave Interference -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">01</div>
                <div class="demo-title">
                    <h2>The Hidden Code</h2>
                    <p>Wave Interference & Sine/Cosine Emergence</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="wave-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="toggleWaveAnimation(1)">Play/Pause</button>
                    <div class="slider-container">
                        <label>Frequency:</label>
                        <input type="range" id="freq1" min="1" max="10" value="3" step="0.1">
                        <span id="freq1-value">3</span>
                    </div>
                    <div class="slider-container">
                        <label>Amplitude:</label>
                        <input type="range" id="amp1" min="0" max="100" value="50">
                    </div>
                </div>
                <div class="info-panel" id="wave-info">
                    <div>Phase: <span id="phase-display">0.00</span> rad</div>
                    <div>Interference: <span id="interference-display">Constructive</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 2: Geometric Classification -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">02</div>
                <div class="demo-title">
                    <h2>Identity Through Distinction</h2>
                    <p>Euclid's Angle Classification System</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="angle-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="randomizeAngle()">Random Angle</button>
                    <button onclick="toggleAngleAnimation()">Animate</button>
                </div>
                <div class="info-panel">
                    <div>Angle: <span id="angle-value">45.00</span>°</div>
                    <div>Type: <span id="angle-type">Acute</span></div>
                    <div>Cosine: <span id="cosine-value">0.707</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 3: Cosine Alignment -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">03</div>
                <div class="demo-title">
                    <h2>Cosine Alignment</h2>
                    <p>Billiard Ball Collision Dynamics</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="billiard-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="resetBilliards()">Reset</button>
                    <button onclick="toggleBilliardAnimation()">Play/Pause</button>
                    <div class="slider-container">
                        <label>Impact Angle:</label>
                        <input type="range" id="impact-angle" min="0" max="180" value="45">
                    </div>
                </div>
                <div class="info-panel">
                    <div>Impact Cosine: <span id="impact-cosine">0.707</span></div>
                    <div>Energy Transfer: <span id="energy-transfer">50%</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 4: Sine Deviation -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">04</div>
                <div class="demo-title">
                    <h2>Sine Deviation</h2>
                    <p>Tangent Explosion at Boundaries</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="tangent-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="toggleTangentAnimation()">Animate</button>
                    <div class="slider-container">
                        <label>Angle:</label>
                        <input type="range" id="tangent-angle" min="0" max="89" value="45" step="0.1">
                        <span id="tangent-angle-value">45°</span>
                    </div>
                </div>
                <div class="info-panel">
                    <div>Sine: <span id="sine-value">0.707</span></div>
                    <div>Cosine: <span id="cos-value">0.707</span></div>
                    <div>Tangent: <span id="tan-value">1.000</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 5: Three-Body Problem -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">05</div>
                <div class="demo-title">
                    <h2>Angle Reality Classification</h2>
                    <p>Three-Body Gravitational System</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="gravity-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="resetGravity()">Reset</button>
                    <button onclick="toggleGravityAnimation()">Play/Pause</button>
                    <button onclick="addTrails()">Toggle Trails</button>
                </div>
                <div class="info-panel">
                    <div>System Energy: <span id="system-energy">-1.234</span></div>
                    <div>Stability: <span id="stability">Chaotic</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 6: Billiard Pi -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">06</div>
                <div class="demo-title">
                    <h2>Boundary Enforcement</h2>
                    <p>Computing π Through Collisions</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="pi-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="startPiCalculation()">Start</button>
                    <button onclick="resetPiCalculation()">Reset</button>
                    <div class="slider-container">
                        <label>Mass Ratio:</label>
                        <input type="range" id="mass-ratio" min="1" max="6" value="2">
                        <span>10<sup id="mass-power">2</sup></span>
                    </div>
                </div>
                <div class="info-panel">
                    <div>Collisions: <span id="collision-count">0</span></div>
                    <div>π Approximation: <span id="pi-approximation">0.000</span></div>
                    <div>Error: <span id="pi-error">100%</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 7: Prime Spiral -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">07</div>
                <div class="demo-title">
                    <h2>Prime Uniqueness</h2>
                    <p>Ulam Spiral & Trajectory Mapping</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="prime-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="togglePrimeAnimation()">Animate</button>
                    <button onclick="switchPrimeView()">Switch View</button>
                    <div class="slider-container">
                        <label>Zoom:</label>
                        <input type="range" id="prime-zoom" min="1" max="10" value="5">
                    </div>
                </div>
                <div class="info-panel">
                    <div>Primes Found: <span id="prime-count">0</span></div>
                    <div>Density: <span id="prime-density">0%</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 8: Flocking -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">08</div>
                <div class="demo-title">
                    <h2>Multi-Perspective Coherence</h2>
                    <p>Trigonometric Flocking Behavior</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="flock-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="resetFlock()">Reset</button>
                    <button onclick="toggleFlockAnimation()">Play/Pause</button>
                    <div class="slider-container">
                        <label>Coherence:</label>
                        <input type="range" id="coherence" min="0" max="100" value="50">
                    </div>
                </div>
                <div class="info-panel">
                    <div>Boids: <span id="boid-count">50</span></div>
                    <div>Average Alignment: <span id="alignment">0.00</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 9: SEP Framework -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">09</div>
                <div class="demo-title">
                    <h2>SEP Operationalization</h2>
                    <p>64-bit Quantum State Detection</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="sep-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="runQBSA()">Run QBSA</button>
                    <button onclick="runQFH()">Run QFH</button>
                    <button onclick="resetSEP()">Reset</button>
                </div>
                <div class="info-panel">
                    <div>State Vector: <span id="state-vector">|000...000⟩</span></div>
                    <div>Coherence: <span id="coherence-level">1.000</span></div>
                    <div>Ruptures Detected: <span id="rupture-count">0</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 10: Fluid Dynamics -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">10</div>
                <div class="demo-title">
                    <h2>Particle Fluid</h2>
                    <p>Particle-based fluid with boundary rotation</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="fluid-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="resetFluid()">Reset</button>
                    <button onclick="toggleFluidAnimation()">Play/Pause</button>
                    <button onclick="addVortex()">Add Vortex</button>
                </div>
                <div class="info-panel">
                    <div>Vorticity: <span id="vorticity">0.00</span></div>
                    <div>Reynolds Number: <span id="reynolds">1000</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 11: Black-Scholes -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">11</div>
                <div class="demo-title">
                    <h2>Derivative Applications</h2>
                    <p>Black-Scholes with SEP Enhancement</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="options-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="calculateOptions()">Calculate</button>
                    <div class="slider-container">
                        <label>Volatility:</label>
                        <input type="range" id="volatility" min="10" max="100" value="30">
                        <span id="vol-value">30%</span>
                    </div>
                </div>
                <div class="info-panel">
                    <div>Traditional Time: <span id="trad-time">0.00ms</span></div>
                    <div>SEP Time: <span id="sep-time">0.00ms</span></div>
                    <div>Speedup: <span id="speedup">0.0x</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 12: Reality's Code -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">12</div>
                <div class="demo-title">
                    <h2>Reality's Code</h2>
                    <p>Unified Meta-Visualization</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="meta-canvas" width="1200" height="800"></canvas>
                <div class="controls">
                    <button onclick="toggleMetaAnimation()">Play/Pause</button>
                    <button onclick="cycleMetaMode()">Change Mode</button>
                </div>
                <div class="info-panel">
                    <div>Integration Level: <span id="integration">0%</span></div>
                    <div>Framework Status: <span id="framework-status">Initializing...</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global animation states
        let animations = {};
        
        // Scene 1: Wave Interference
        function initWaveDemo() {
            const canvas = document.getElementById('wave-canvas');
            const ctx = canvas.getContext('2d');
            let time = 0;
            let isPlaying = true;
            
            function drawWave() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const freq1 = parseFloat(document.getElementById('freq1').value);
                const amp1 = parseFloat(document.getElementById('amp1').value);
                
                // Draw grid
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.stroke();
                }
                
                // Draw multiple waves
                for (let wave = 0; wave < 3; wave++) {
                    ctx.strokeStyle = `hsl(${240 + wave * 30}, 70%, 60%)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let x = 0; x < canvas.width; x++) {
                        const y1 = canvas.height/2 + amp1 * Math.sin((x + time * 2) * freq1 * 0.01 + wave * Math.PI/3);
                        if (x === 0) ctx.moveTo(x, y1);
                        else ctx.lineTo(x, y1);
                    }
                    ctx.stroke();
                }
                
                // Draw interference pattern
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x++) {
                    let y = canvas.height/2;
                    for (let wave = 0; wave < 3; wave++) {
                        y += amp1/3 * Math.sin((x + time * 2) * freq1 * 0.01 + wave * Math.PI/3);
                    }
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Update info
                document.getElementById('phase-display').textContent = ((time * 0.02) % (2 * Math.PI)).toFixed(2);
                document.getElementById('freq1-value').textContent = freq1;
                
                if (isPlaying) {
                    time++;
                    requestAnimationFrame(drawWave);
                }
            }
            
            drawWave();
            animations.wave = { draw: drawWave, isPlaying };
        }
        
        function toggleWaveAnimation() {
            animations.wave.isPlaying = !animations.wave.isPlaying;
            if (animations.wave.isPlaying) animations.wave.draw();
        }
        
        // Scene 2: Angle Classification
        function initAngleDemo() {
            const canvas = document.getElementById('angle-canvas');
            const ctx = canvas.getContext('2d');
            let angle = 45;
            let targetAngle = 45;
            let isAnimating = false;
            
            function drawAngle() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = 150;
                
                // Draw coordinate system
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(canvas.width, centerY);
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, canvas.height);
                ctx.stroke();
                
                // Draw angle arc
                const angleRad = angle * Math.PI / 180;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius/2, 0, angleRad, false);
                
                // Color based on angle type
                let color, type;
                if (angle < 90) {
                    color = '#00ff00';
                    type = 'Acute';
                } else if (angle === 90) {
                    color = '#ff0000';
                    type = 'Right';
                } else {
                    color = '#0088ff';
                    type = 'Obtuse';
                }
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw angle lines
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + radius * Math.cos(0), centerY + radius * Math.sin(0));
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + radius * Math.cos(angleRad), centerY + radius * Math.sin(angleRad));
                ctx.stroke();
                
                // Draw angle value
                ctx.fillStyle = color;
                ctx.font = '24px monospace';
                ctx.fillText(`${angle.toFixed(1)}°`, centerX + 20, centerY - 20);
                
                // Update info
                document.getElementById('angle-value').textContent = angle.toFixed(2);
                document.getElementById('angle-type').textContent = type;
                document.getElementById('cosine-value').textContent = Math.cos(angleRad).toFixed(3);
                
                if (isAnimating) {
                    angle += 0.5;
                    if (angle > 180) angle = 0;
                    requestAnimationFrame(drawAngle);
                } else if (Math.abs(angle - targetAngle) > 0.1) {
                    angle += (targetAngle - angle) * 0.1;
                    requestAnimationFrame(drawAngle);
                }
            }
            
            drawAngle();
            animations.angle = { draw: drawAngle, isAnimating };
            
            // Add mouse interaction
            canvas.addEventListener('mousemove', (e) => {
                if (!isAnimating) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left - canvas.width/2;
                    const y = e.clientY - rect.top - canvas.height/2;
                    targetAngle = Math.atan2(y, x) * 180 / Math.PI;
                    if (targetAngle < 0) targetAngle += 360;
                    if (targetAngle > 180) targetAngle = 180;
                    drawAngle();
                }
            });
        }
        
        function toggleAngleAnimation() {
            animations.angle.isAnimating = !animations.angle.isAnimating;
            if (animations.angle.isAnimating) animations.angle.draw();
        }
        
        function randomizeAngle() {
            animations.angle.targetAngle = Math.random() * 180;
            animations.angle.draw();
        }
        
        // Scene 3: Billiard Collision
        function initBilliardDemo() {
            const canvas = document.getElementById('billiard-canvas');
            const ctx = canvas.getContext('2d');
            
            let balls = [
                { x: 200, y: 200, vx: 5, vy: 0, r: 20, color: '#ff0000' },
                { x: 600, y: 200, vx: -3, vy: 0, r: 20, color: '#0088ff' }
            ];
            let isPlaying = true;
            let impactAngle = 45;
            
            function drawBilliards() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw table
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(50, 50, canvas.width - 100, canvas.height - 100);
                
                // Update and draw balls
                balls.forEach((ball, i) => {
                    if (isPlaying) {
                        ball.x += ball.vx;
                        ball.y += ball.vy;
                        
                        // Wall collision
                        if (ball.x - ball.r <= 50 || ball.x + ball.r >= canvas.width - 50) {
                            ball.vx *= -0.9;
                            ball.x = Math.max(50 + ball.r, Math.min(canvas.width - 50 - ball.r, ball.x));
                        }
                        if (ball.y - ball.r <= 50 || ball.y + ball.r >= canvas.height - 50) {
                            ball.vy *= -0.9;
                            ball.y = Math.max(50 + ball.r, Math.min(canvas.height - 50 - ball.r, ball.y));
                        }
                        
                        // Ball collision
                        for (let j = i + 1; j < balls.length; j++) {
                            const other = balls[j];
                            const dx = other.x - ball.x;
                            const dy = other.y - ball.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < ball.r + other.r) {
                                // Calculate collision angle
                                const angle = Math.atan2(dy, dx);
                                const sin = Math.sin(angle);
                                const cos = Math.cos(angle);
                                
                                // Rotate velocities
                                const vx1 = ball.vx * cos + ball.vy * sin;
                                const vy1 = ball.vy * cos - ball.vx * sin;
                                const vx2 = other.vx * cos + other.vy * sin;
                                const vy2 = other.vy * cos - other.vx * sin;
                                
                                // Swap velocities
                                ball.vx = vx2 * cos - vy1 * sin;
                                ball.vy = vy1 * cos + vx2 * sin;
                                other.vx = vx1 * cos - vy2 * sin;
                                other.vy = vy2 * cos + vx1 * sin;
                                
                                // Separate balls
                                const overlap = ball.r + other.r - dist;
                                ball.x -= overlap * cos / 2;
                                ball.y -= overlap * sin / 2;
                                other.x += overlap * cos / 2;
                                other.y += overlap * sin / 2;
                                
                                // Update impact info
                                const impactCos = Math.cos(angle);
                                document.getElementById('impact-cosine').textContent = impactCos.toFixed(3);
                                document.getElementById('energy-transfer').textContent = (Math.abs(impactCos) * 100).toFixed(0) + '%';
                            }
                        }
                    }
                    
                    // Draw ball
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                    ctx.fillStyle = ball.color;
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw velocity vector
                    ctx.beginPath();
                    ctx.moveTo(ball.x, ball.y);
                    ctx.lineTo(ball.x + ball.vx * 10, ball.y + ball.vy * 10);
                    ctx.strokeStyle = ball.color;
                    ctx.stroke();
                });
                
                if (isPlaying) {
                    requestAnimationFrame(drawBilliards);
                }
            }
            
            drawBilliards();
            animations.billiard = { draw: drawBilliards, isPlaying };
        }
        
        function resetBilliards() {
            const impactAngle = parseFloat(document.getElementById('impact-angle').value);
            const rad = impactAngle * Math.PI / 180;
            animations.billiard.balls = [
                { x: 200, y: 200, vx: 5 * Math.cos(rad), vy: 5 * Math.sin(rad), r: 20, color: '#ff0000' },
                { x: 600, y: 200, vx: -3, vy: 0, r: 20, color: '#0088ff' }
            ];
            animations.billiard.draw();
        }
        
        function toggleBilliardAnimation() {
            animations.billiard.isPlaying = !animations.billiard.isPlaying;
            if (animations.billiard.isPlaying) animations.billiard.draw();
        }
        
        // Scene 4: Tangent Explosion
        function initTangentDemo() {
            const canvas = document.getElementById('tangent-canvas');
            const ctx = canvas.getContext('2d');
            let animationAngle = 0;
            let isAnimating = false;
            
            function drawTangent() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const angle = isAnimating ? animationAngle : parseFloat(document.getElementById('tangent-angle').value);
                const rad = angle * Math.PI / 180;
                
                // Draw coordinate system
                const centerX = 200;
                const centerY = canvas.height / 2;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(canvas.width, centerY);
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, canvas.height);
                ctx.stroke();
                
                // Draw unit circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw angle
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + 100 * Math.cos(rad), centerY - 100 * Math.sin(rad));
                ctx.stroke();
                
                // Draw functions
                const graphX = 400;
                const graphWidth = canvas.width - graphX - 50;
                
                // Sin curve
                ctx.strokeStyle = '#ff0000';
                ctx.beginPath();
                for (let x = 0; x < graphWidth; x++) {
                    const a = (x / graphWidth) * Math.PI / 2;
                    const y = centerY - 150 * Math.sin(a);
                    if (x === 0) ctx.moveTo(graphX + x, y);
                    else ctx.lineTo(graphX + x, y);
                }
                ctx.stroke();
                
                // Cos curve
                ctx.strokeStyle = '#0088ff';
                ctx.beginPath();
                for (let x = 0; x < graphWidth; x++) {
                    const a = (x / graphWidth) * Math.PI / 2;
                    const y = centerY - 150 * Math.cos(a);
                    if (x === 0) ctx.moveTo(graphX + x, y);
                    else ctx.lineTo(graphX + x, y);
                }
                ctx.stroke();
                
                // Tan curve (with clipping for explosion)
                ctx.strokeStyle = '#ff00ff';
                ctx.beginPath();
                for (let x = 0; x < graphWidth; x++) {
                    const a = (x / graphWidth) * Math.PI / 2;
                    let tanVal = Math.tan(a);
                    tanVal = Math.max(-5, Math.min(5, tanVal)); // Clamp for visibility
                    const y = centerY - 30 * tanVal;
                    if (x === 0) ctx.moveTo(graphX + x, y);
                    else ctx.lineTo(graphX + x, y);
                }
                ctx.stroke();
                
                // Draw current angle marker
                const markerX = graphX + (rad / (Math.PI / 2)) * graphWidth;
                ctx.strokeStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(markerX, 50);
                ctx.lineTo(markerX, canvas.height - 50);
                ctx.stroke();
                
                // Update values
                document.getElementById('tangent-angle-value').textContent = angle.toFixed(0) + '°';
                document.getElementById('sine-value').textContent = Math.sin(rad).toFixed(3);
                document.getElementById('cos-value').textContent = Math.cos(rad).toFixed(3);
                document.getElementById('tan-value').textContent = Math.tan(rad).toFixed(3);
                
                if (isAnimating) {
                    animationAngle = (animationAngle + 0.5) % 90;
                    requestAnimationFrame(drawTangent);
                }
            }
            
            drawTangent();
            animations.tangent = { draw: drawTangent, isAnimating };
            
            document.getElementById('tangent-angle').addEventListener('input', () => {
                if (!isAnimating) drawTangent();
            });
        }
        
        function toggleTangentAnimation() {
            animations.tangent.isAnimating = !animations.tangent.isAnimating;
            if (animations.tangent.isAnimating) animations.tangent.draw();
        }
        
        // Scene 5: Three-Body Problem
        function initGravityDemo() {
            const canvas = document.getElementById('gravity-canvas');
            const ctx = canvas.getContext('2d');
            const G = 0.5;

            const gravityState = {
                bodies: [
                    { x: 400, y: 300, vx: 0, vy: -0.5, m: 20, color: '#ff0000', trail: [] },
                    { x: 600, y: 300, vx: 0, vy: 0.5, m: 20, color: '#0088ff', trail: [] },
                    { x: 500, y: 200, vx: 0.5, vy: 0, m: 20, color: '#00ff00', trail: [] }
                ],
                showTrails: false,
                isPlaying: true,
                draw: null
            };

            function drawGravity() {
                const { bodies, showTrails, isPlaying } = gravityState;
                if (!showTrails) {
                    ctx.fillStyle = 'rgba(15, 15, 15, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                if (isPlaying) {
                    // Update forces
                    bodies.forEach((body, i) => {
                        let fx = 0, fy = 0;
                        
                        bodies.forEach((other, j) => {
                            if (i !== j) {
                                const dx = other.x - body.x;
                                const dy = other.y - body.y;
                                const r2 = dx * dx + dy * dy;
                                const r = Math.sqrt(r2);
                                const f = G * body.m * other.m / r2;
                                
                                fx += f * dx / r;
                                fy += f * dy / r;
                            }
                        });
                        
                        body.vx += fx / body.m;
                        body.vy += fy / body.m;
                    });
                    
                    // Update positions
                    bodies.forEach(body => {
                        body.x += body.vx;
                        body.y += body.vy;
                        
                        // Add to trail
                        body.trail.push({ x: body.x, y: body.y });
                        if (body.trail.length > 200) body.trail.shift();
                    });
                }
                
                // Draw trails
                if (showTrails) {
                    bodies.forEach(body => {
                        ctx.strokeStyle = body.color;
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        body.trail.forEach((point, i) => {
                            if (i === 0) ctx.moveTo(point.x, point.y);
                            else ctx.lineTo(point.x, point.y);
                        });
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    });
                }
                
                // Draw bodies
                bodies.forEach(body => {
                    ctx.beginPath();
                    ctx.arc(body.x, body.y, body.m, 0, Math.PI * 2);
                    ctx.fillStyle = body.color;
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // Draw angle indicators
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < bodies.length; i++) {
                    for (let j = i + 1; j < bodies.length; j++) {
                        ctx.beginPath();
                        ctx.moveTo(bodies[i].x, bodies[i].y);
                        ctx.lineTo(bodies[j].x, bodies[j].y);
                        ctx.stroke();
                    }
                }
                
                if (isPlaying) {
                    requestAnimationFrame(drawGravity);
                }
            }

            gravityState.draw = drawGravity;
            animations.gravity = gravityState;
            drawGravity();
        }

        function resetGravity() {
            animations.gravity.bodies = [
                { x: 400, y: 300, vx: 0, vy: -0.5, m: 20, color: '#ff0000', trail: [] },
                { x: 600, y: 300, vx: 0, vy: 0.5, m: 20, color: '#0088ff', trail: [] },
                { x: 500, y: 200, vx: 0.5, vy: 0, m: 20, color: '#00ff00', trail: [] }
            ];
            animations.gravity.draw();
        }

        function toggleGravityAnimation() {
            animations.gravity.isPlaying = !animations.gravity.isPlaying;
            if (animations.gravity.isPlaying) animations.gravity.draw();
        }

        function addTrails() {
            animations.gravity.showTrails = !animations.gravity.showTrails;
        }
        
        // Scene 6: Pi Calculation
        function initPiDemo() {
            const canvas = document.getElementById('pi-canvas');
            const ctx = canvas.getContext('2d');
            let collisions = 0;
            let isCalculating = false;
            let digitString = '';
            let lastCollisions = 0;
            
            let block1 = { x: 200, vx: 0, m: 1, w: 50 };
            let block2 = { x: 400, vx: -1, m: 100, w: 100 };
            
           function drawPi() {
                if (animations.pi) {
                    collisions = animations.pi.collisions;
                    block1 = animations.pi.block1;
                    block2 = animations.pi.block2;
                    digitString = animations.pi.digitString;
                }
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw floor
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - 50);
                ctx.lineTo(canvas.width, canvas.height - 50);
                ctx.stroke();
                
                // Draw wall
                ctx.fillStyle = '#333333';
                ctx.fillRect(0, 100, 20, canvas.height - 150);
                
                // Update physics
                if (isCalculating) {
                    // Block collision
                    if (block1.x + block1.w >= block2.x) {
                        const v1 = block1.vx;
                        const v2 = block2.vx;
                        const m1 = block1.m;
                        const m2 = block2.m;
                        
                        block1.vx = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2);
                        block2.vx = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2);
                        collisions++;
                    }
                    
                    // Wall collision
                    if (block1.x <= 20) {
                        block1.vx = Math.abs(block1.vx);
                        collisions++;
                    }
                    
                    // Update positions
                    block1.x += block1.vx * 5;
                    block2.x += block2.vx * 5;

                    if (collisions > lastCollisions) {
                        const str = collisions.toString();
                        digitString = str.length > 1 ? str[0] + '.' + str.slice(1) : str;
                        lastCollisions = collisions;
                        animations.pi.digitString = digitString;
                    }
                    animations.pi.collisions = collisions;
                    animations.pi.block1 = block1;
                    animations.pi.block2 = block2;
                }
                
                // Draw blocks
                const groundY = canvas.height - 50;
                
                // Block 1
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(block1.x, groundY - block1.w, block1.w, block1.w);
                ctx.strokeStyle = '#ffffff';
                ctx.strokeRect(block1.x, groundY - block1.w, block1.w, block1.w);
                
                // Block 2
                ctx.fillStyle = '#0088ff';
                ctx.fillRect(block2.x, groundY - block2.w, block2.w, block2.w);
                ctx.strokeStyle = '#ffffff';
                ctx.strokeRect(block2.x, groundY - block2.w, block2.w, block2.w);
                
                // Draw velocities
                ctx.font = '16px monospace';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`v1: ${block1.vx.toFixed(2)}`, block1.x, groundY - block1.w - 10);
                ctx.fillText(`v2: ${block2.vx.toFixed(2)}`, block2.x, groundY - block2.w - 10);

                // Update info
                document.getElementById('collision-count').textContent = collisions;
                const piApprox = collisions / Math.pow(10, Math.floor(Math.log10(block2.m) / 2));
                document.getElementById('pi-approximation').textContent = piApprox.toFixed(6);
                document.getElementById('pi-error').textContent = (Math.abs(piApprox - Math.PI) / Math.PI * 100).toFixed(2) + '%';

                ctx.font = '24px monospace';
                ctx.fillStyle = '#00ff00';
                ctx.fillText(digitString, 20, 40);
                
                if (isCalculating && Math.abs(block2.vx) > 0.001) {
                    requestAnimationFrame(drawPi);
                } else {
                    isCalculating = false;
                }
            }
            
            drawPi();
            animations.pi = { draw: drawPi, isCalculating, collisions, block1, block2, digitString };
            animations.pi.digitString = digitString;
        }
        
        function startPiCalculation() {
            animations.pi.isCalculating = true;
            animations.pi.draw();
            animations.pi.digitString = digitString;
        }
        
        function resetPiCalculation() {
            const power = parseInt(document.getElementById('mass-ratio').value);
            animations.pi.collisions = 0;
            animations.pi.block1 = { x: 200, vx: 0, m: 1, w: 50 };
            animations.pi.block2 = { x: 400, vx: -1, m: Math.pow(100, power), w: 100 };
            animations.pi.isCalculating = false;
            animations.pi.digitString = '';
            document.getElementById('mass-power').textContent = power * 2;
            animations.pi.draw();
        }
        
        // Initialize all demos
        window.onload = function() {
            initWaveDemo();
            initAngleDemo();
            initBilliardDemo();
            initTangentDemo();
            initGravityDemo();
            initPiDemo();
            
            // Initialize remaining demos with placeholder canvases
            const remainingCanvases = ['prime-canvas', 'flock-canvas', 'sep-canvas', 'fluid-canvas', 'options-canvas'];
            remainingCanvases.forEach(id => {
                const canvas = document.getElementById(id);
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#333';
                ctx.font = '24px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Demo Loading...', canvas.width/2, canvas.height/2);
            });
        };
    </script>

    <!-- Module script for Scene11 -->
    <script type="module">
        import Scene11 from '../../assets/js/demos/scenes/scene11.js';

        let scene11;

        function initOptionsDemo() {
            const canvas = document.getElementById('options-canvas');
            const ctx = canvas.getContext('2d');
            const settings = { speed: 1, intensity: 30 };
            scene11 = new Scene11(canvas, ctx, settings);
            scene11.init().then(() => requestAnimationFrame(animateOptions));
        }

        function animateOptions(ts) {
            if (scene11) {
                scene11.animate(ts);
                requestAnimationFrame(animateOptions);
            }
        }

        window.calculateOptions = function() {
            if (!scene11) return;
            scene11.calculatePriceSurface();
            document.getElementById('trad-time').textContent = scene11.traditionalCalcTime.toFixed(2) + 'ms';
            document.getElementById('sep-time').textContent = scene11.sepCalcTime.toFixed(2) + 'ms';
            document.getElementById('speedup').textContent = scene11.speedup.toFixed(1) + 'x';
        };

        window.addEventListener('load', () => {
            const volSlider = document.getElementById('volatility');
            const volValue = document.getElementById('vol-value');
            volSlider.addEventListener('input', (e) => {
                volValue.textContent = e.target.value + '%';
                if (scene11) scene11.updateVolatility(+e.target.value);
            });
            initOptionsDemo();
        });
    </script>

    <!-- Module script for Scene12 -->
    <script type="module">
        import Scene12 from '../assets/js/demos/scenes/scene12.js';
        import Physics from '../assets/js/demos/utils/physics.js';
        import MathLib from '../assets/js/demos/utils/math-lib.js';
        import EventManager from '../assets/js/demos/core/event-manager.js';
        import StateManager from '../assets/js/demos/core/state-manager.js';
        import RenderPipeline from '../assets/js/demos/core/render-pipeline.js';

        // Global Scene12 instance
        let scene12;

        async function initMetaDemo() {
            const canvas = document.getElementById('meta-canvas');
            const ctx = canvas.getContext('2d');
            
            const settings = { speed: 1 };
            const physics = new Physics();
            await physics.init();
            const math = new MathLib();
            const eventManager = new EventManager(canvas);
            await eventManager.init();
            const stateManager = new StateManager(settings);
            const renderPipeline = new RenderPipeline(canvas, ctx);

            scene12 = new Scene12(canvas, ctx, settings, physics, math, eventManager, stateManager, renderPipeline);
            await scene12.init();
            requestAnimationFrame(animateMeta);
        }

        function animateMeta(timestamp) {
            scene12.animate(timestamp);
            requestAnimationFrame(animateMeta);
        }

        // Button handlers
        window.toggleMetaAnimation = function() {
            if (scene12) {
                scene12.paused = !scene12.paused;
            }
        };

        window.cycleMetaMode = function() {
            if (scene12) {
                scene12.activeVisualization = (scene12.activeVisualization + 1) % scene12.visualizationNames.length;
            }
        };

        // Call init on load
        window.addEventListener('load', () => initMetaDemo());
    </script>
</body>
</html>