<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEP Framework - Interactive Demos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow-x: hidden;
        }

        .hero {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0a 100%);
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 255, 0.03) 2px,
                rgba(255, 255, 255, 0.03) 4px
            );
            animation: scan 8s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        h1 {
            font-size: 4rem;
            font-weight: 300;
            letter-spacing: -2px;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            z-index: 1;
        }

        .subtitle {
            font-size: 1.5rem;
            color: #888;
            margin-bottom: 3rem;
            z-index: 1;
        }

        .demos-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 4rem 2rem;
        }

        .demo-section {
            margin-bottom: 6rem;
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 0.8s ease forwards;
        }

        .demo-section:nth-child(1) { animation-delay: 0.1s; }
        .demo-section:nth-child(2) { animation-delay: 0.2s; }
        .demo-section:nth-child(3) { animation-delay: 0.3s; }
        .demo-section:nth-child(4) { animation-delay: 0.4s; }
        .demo-section:nth-child(5) { animation-delay: 0.5s; }
        .demo-section:nth-child(6) { animation-delay: 0.6s; }
        .demo-section:nth-child(7) { animation-delay: 0.7s; }
        .demo-section:nth-child(8) { animation-delay: 0.8s; }
        .demo-section:nth-child(9) { animation-delay: 0.9s; }
        .demo-section:nth-child(10) { animation-delay: 1.0s; }
        .demo-section:nth-child(11) { animation-delay: 1.1s; }
        .demo-section:nth-child(12) { animation-delay: 1.2s; }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .demo-header {
            display: flex;
            align-items: center;
            margin-bottom: 2rem;
            position: relative;
        }

        .demo-number {
            font-size: 5rem;
            font-weight: 900;
            color: #1a1a2e;
            margin-right: 2rem;
            line-height: 1;
        }

        .demo-title {
            flex: 1;
        }

        .demo-title h2 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .demo-title p {
            color: #888;
            font-size: 1.1rem;
        }

        .demo-canvas {
            background: #0f0f0f;
            border-radius: 20px;
            padding: 2rem;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            cursor: crosshair;
        }

        .controls {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 50px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: left 0.5s ease;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
        }

        input[type="range"] {
            width: 150px;
            height: 5px;
            background: #333;
            outline: none;
            border-radius: 5px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1.5rem;
            margin-top: 1rem;
            font-family: 'Courier New', monospace;
        }

        .quantum-glow {
            position: absolute;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.3) 0%, transparent 70%);
            pointer-events: none;
            filter: blur(40px);
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(30px, -30px) scale(1.1); }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="hero">
        <div class="quantum-glow" style="top: 10%; left: 10%;"></div>
        <div class="quantum-glow" style="bottom: 10%; right: 10%;"></div>
        <h1>SEP Framework</h1>
        <p class="subtitle">Quantum-Inspired Computational Demonstrations</p>
    </div>

    <div class="demos-container">
        <!-- Scene 1: Wave Interference -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">01</div>
                <div class="demo-title">
                    <h2>The Hidden Code</h2>
                    <p>Wave Interference & Sine/Cosine Emergence</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="wave-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="toggleWaveAnimation(1)">Play/Pause</button>
                    <div class="slider-container">
                        <label>Frequency:</label>
                        <input type="range" id="freq1" min="1" max="10" value="3" step="0.1">
                        <span id="freq1-value">3</span>
                    </div>
                    <div class="slider-container">
                        <label>Amplitude:</label>
                        <input type="range" id="amp1" min="0" max="100" value="50">
                    </div>
                </div>
                <div class="info-panel" id="wave-info">
                    <div>Phase: <span id="phase-display">0.00</span> rad</div>
                    <div>Interference: <span id="interference-display">Constructive</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 2: Geometric Classification -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">02</div>
                <div class="demo-title">
                    <h2>Identity Through Distinction</h2>
                    <p>Euclid's Angle Classification System</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="angle-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="randomizeAngle()">Random Angle</button>
                    <button onclick="toggleAngleAnimation()">Animate</button>
                </div>
                <div class="info-panel">
                    <div>Angle: <span id="angle-value">45.00</span>°</div>
                    <div>Type: <span id="angle-type">Acute</span></div>
                    <div>Cosine: <span id="cosine-value">0.707</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 3: Cosine Alignment -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">03</div>
                <div class="demo-title">
                    <h2>Cosine Alignment</h2>
                    <p>Billiard Ball Collision Dynamics</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="billiard-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="resetBilliards()">Reset</button>
                    <button onclick="toggleBilliardAnimation()">Play/Pause</button>
                    <div class="slider-container">
                        <label>Impact Angle:</label>
                        <input type="range" id="impact-angle" min="0" max="180" value="45">
                    </div>
                </div>
                <div class="info-panel">
                    <div>Impact Cosine: <span id="impact-cosine">0.707</span></div>
                    <div>Energy Transfer: <span id="energy-transfer">50%</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 4: Sine Deviation -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">04</div>
                <div class="demo-title">
                    <h2>Sine Deviation</h2>
                    <p>Tangent Explosion at Boundaries</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="tangent-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="toggleTangentAnimation()">Animate</button>
                    <div class="slider-container">
                        <label>Angle:</label>
                        <input type="range" id="tangent-angle" min="0" max="89" value="45" step="0.1">
                        <span id="tangent-angle-value">45°</span>
                    </div>
                </div>
                <div class="info-panel">
                    <div>Sine: <span id="sine-value">0.707</span></div>
                    <div>Cosine: <span id="cos-value">0.707</span></div>
                    <div>Tangent: <span id="tan-value">1.000</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 5: Three-Body Problem -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">05</div>
                <div class="demo-title">
                    <h2>Angle Reality Classification</h2>
                    <p>Three-Body Gravitational System</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="gravity-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="resetGravity()">Reset</button>
                    <button onclick="toggleGravityAnimation()">Play/Pause</button>
                    <button onclick="addTrails()">Toggle Trails</button>
                </div>
                <div class="info-panel">
                    <div>System Energy: <span id="system-energy">-1.234</span></div>
                    <div>Stability: <span id="stability">Chaotic</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 6: Billiard Pi -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">06</div>
                <div class="demo-title">
                    <h2>Boundary Enforcement</h2>
                    <p>Computing π Through Collisions</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="pi-canvas" width="1200" height="400"></canvas>
                <div class="controls">
                    <button onclick="startPiCalculation()">Start</button>
                    <button onclick="resetPiCalculation()">Reset</button>
                    <div class="slider-container">
                        <label>Mass Ratio:</label>
                        <input type="range" id="mass-ratio" min="1" max="6" value="2">
                        <span>10<sup id="mass-power">2</sup></span>
                    </div>
                </div>
                <div class="info-panel">
                    <div>Collisions: <span id="collision-count">0</span></div>
                    <div>π Approximation: <span id="pi-approximation">0.000</span></div>
                    <div>Error: <span id="pi-error">100%</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 7: Prime Spiral -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">07</div>
                <div class="demo-title">
                    <h2>Prime Uniqueness</h2>
                    <p>Ulam Spiral & Trajectory Mapping</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="prime-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="togglePrimeAnimation()">Animate</button>
                    <button onclick="switchPrimeView()">Switch View</button>
                    <div class="slider-container">
                        <label>Zoom:</label>
                        <input type="range" id="prime-zoom" min="1" max="10" value="5">
                    </div>
                </div>
                <div class="info-panel">
                    <div>Primes Found: <span id="prime-count">0</span></div>
                    <div>Density: <span id="prime-density">0%</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 8: Flocking -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">08</div>
                <div class="demo-title">
                    <h2>Multi-Perspective Coherence</h2>
                    <p>Trigonometric Flocking Behavior</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="flock-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="resetFlock()">Reset</button>
                    <button onclick="toggleFlockAnimation()">Play/Pause</button>
                    <div class="slider-container">
                        <label>Coherence:</label>
                        <input type="range" id="coherence" min="0" max="100" value="50">
                    </div>
                </div>
                <div class="info-panel">
                    <div>Boids: <span id="boid-count">50</span></div>
                    <div>Average Alignment: <span id="alignment">0.00</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 9: SEP Framework -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">09</div>
                <div class="demo-title">
                    <h2>SEP Operationalization</h2>
                    <p>64-bit Quantum State Detection</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="sep-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="runQBSA()">Run QBSA</button>
                    <button onclick="runQFH()">Run QFH</button>
                    <button onclick="resetSEP()">Reset</button>
                </div>
                <div class="info-panel">
                    <div>State Vector: <span id="state-vector">|000...000⟩</span></div>
                    <div>Coherence: <span id="coherence-level">1.000</span></div>
                    <div>Ruptures Detected: <span id="rupture-count">0</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 10: Fluid Dynamics -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">10</div>
                <div class="demo-title">
                    <h2>Unified Emergence</h2>
                    <p>Navier-Stokes Vorticity Simulation</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="fluid-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="resetFluid()">Reset</button>
                    <button onclick="toggleFluidAnimation()">Play/Pause</button>
                    <button onclick="addVortex()">Add Vortex</button>
                </div>
                <div class="info-panel">
                    <div>Vorticity: <span id="vorticity">0.00</span></div>
                    <div>Reynolds Number: <span id="reynolds">1000</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 11: Black-Scholes -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">11</div>
                <div class="demo-title">
                    <h2>Derivative Applications</h2>
                    <p>Black-Scholes with SEP Enhancement</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="options-canvas" width="1200" height="600"></canvas>
                <div class="controls">
                    <button onclick="calculateOptions()">Calculate</button>
                    <div class="slider-container">
                        <label>Volatility:</label>
                        <input type="range" id="volatility" min="10" max="100" value="30">
                        <span id="vol-value">30%</span>
                    </div>
                </div>
                <div class="info-panel">
                    <div>Traditional Time: <span id="trad-time">0.00ms</span></div>
                    <div>SEP Time: <span id="sep-time">0.00ms</span></div>
                    <div>Speedup: <span id="speedup">0.0x</span></div>
                </div>
            </div>
        </div>

        <!-- Scene 12: Reality's Code -->
        <div class="demo-section">
            <div class="demo-header">
                <div class="demo-number">12</div>
                <div class="demo-title">
                    <h2>Reality's Code</h2>
                    <p>Unified Meta-Visualization</p>
                </div>
            </div>
            <div class="demo-canvas">
                <canvas id="meta-canvas" width="1200" height="800"></canvas>
                <div class="controls">
                    <button onclick="toggleMetaAnimation()">Play/Pause</button>
                    <button onclick="cycleMetaMode()">Change Mode</button>
                </div>
                <div class="info-panel">
                    <div>Integration Level: <span id="integration">0%</span></div>
                    <div>Framework Status: <span id="framework-status">Initializing...</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global animation states
        let animations = {};
        
        // Scene 1: Wave Interference
        function initWaveDemo() {
            const canvas = document.getElementById('wave-canvas');
            const ctx = canvas.getContext('2d');
            let time = 0;
            let isPlaying = true;
            
            function drawWave() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const freq1 = parseFloat(document.getElementById('freq1').value);
                const amp1 = parseFloat(document.getElementById('amp1').value);
                
                // Draw grid
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.stroke();
                }
                
                // Draw multiple waves
                for (let wave = 0; wave < 3; wave++) {
                    ctx.strokeStyle = `hsl(${240 + wave * 30}, 70%, 60%)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let x = 0; x < canvas.width; x++) {
                        const y1 = canvas.height/2 + amp1 * Math.sin((x + time * 2) * freq1 * 0.01 + wave * Math.PI/3);
                        if (x === 0) ctx.moveTo(x, y1);
                        else ctx.lineTo(x, y1);
                    }
                    ctx.stroke();
                }
                
                // Draw interference pattern
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x++) {
                    let y = canvas.height/2;
                    for (let wave = 0; wave < 3; wave++) {
                        y += amp1/3 * Math.sin((x + time * 2) * freq1 * 0.01 + wave * Math.PI/3);
                    }
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Update info
                document.getElementById('phase-display').textContent = ((time * 0.02) % (2 * Math.PI)).toFixed(2);
                document.getElementById('freq1-value').textContent = freq1;
                
                if (isPlaying) {
                    time++;
                    requestAnimationFrame(drawWave);
                }
            }
            
            drawWave();
            animations.wave = { draw: drawWave, isPlaying };
        }
        
        function toggleWaveAnimation() {
            animations.wave.isPlaying = !animations.wave.isPlaying;
            if (animations.wave.isPlaying) animations.wave.draw();
        }
        
        // Scene 2: Angle Classification
        function initAngleDemo() {
            const canvas = document.getElementById('angle-canvas');
            const ctx = canvas.getContext('2d');
            let angle = 45;
            let targetAngle = 45;
            let isAnimating = false;
            
            function drawAngle() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = 150;
                
                // Draw coordinate system
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(canvas.width, centerY);
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, canvas.height);
                ctx.stroke();
                
                // Draw angle arc
                const angleRad = angle * Math.PI / 180;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius/2, 0, angleRad, false);
                
                // Color based on angle type
                let color, type;
                if (angle < 90) {
                    color = '#00ff00';
                    type = 'Acute';
                } else if (angle === 90) {
                    color = '#ff0000';
                    type = 'Right';
                } else {
                    color = '#0088ff';
                    type = 'Obtuse';
                }
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw angle lines
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + radius * Math.cos(0), centerY + radius * Math.sin(0));
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + radius * Math.cos(angleRad), centerY + radius * Math.sin(angleRad));
                ctx.stroke();
                
                // Draw angle value
                ctx.fillStyle = color;
                ctx.font = '24px monospace';
                ctx.fillText(`${angle.toFixed(1)}°`, centerX + 20, centerY - 20);
                
                // Update info
                document.getElementById('angle-value').textContent = angle.toFixed(2);
                document.getElementById('angle-type').textContent = type;
                document.getElementById('cosine-value').textContent = Math.cos(angleRad).toFixed(3);
                
                if (isAnimating) {
                    angle += 0.5;
                    if (angle > 180) angle = 0;
                    requestAnimationFrame(drawAngle);
                } else if (Math.abs(angle - targetAngle) > 0.1) {
                    angle += (targetAngle - angle) * 0.1;
                    requestAnimationFrame(drawAngle);
                }
            }
            
            drawAngle();
            animations.angle = { draw: drawAngle, isAnimating };
            
            // Add mouse interaction
            canvas.addEventListener('mousemove', (e) => {
                if (!isAnimating) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left - canvas.width/2;
                    const y = e.clientY - rect.top - canvas.height/2;
                    targetAngle = Math.atan2(y, x) * 180 / Math.PI;
                    if (targetAngle < 0) targetAngle += 360;
                    if (targetAngle > 180) targetAngle = 180;
                    drawAngle();
                }
            });
        }
        
        function toggleAngleAnimation() {
            animations.angle.isAnimating = !animations.angle.isAnimating;
            if (animations.angle.isAnimating) animations.angle.draw();
        }
        
        function randomizeAngle() {
            animations.angle.targetAngle = Math.random() * 180;
            animations.angle.draw();
        }
        
        // Scene 3: Billiard Collision
        function initBilliardDemo() {
            const canvas = document.getElementById('billiard-canvas');
            const ctx = canvas.getContext('2d');
            
            let balls = [
                { x: 200, y: 200, vx: 5, vy: 0, r: 20, color: '#ff0000' },
                { x: 600, y: 200, vx: -3, vy: 0, r: 20, color: '#0088ff' }
            ];
            let isPlaying = true;
            let impactAngle = 45;
            
            function drawBilliards() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw table
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(50, 50, canvas.width - 100, canvas.height - 100);
                
                // Update and draw balls
                balls.forEach((ball, i) => {
                    if (isPlaying) {
                        ball.x += ball.vx;
                        ball.y += ball.vy;
                        
                        // Wall collision
                        if (ball.x - ball.r <= 50 || ball.x + ball.r >= canvas.width - 50) {
                            ball.vx *= -0.9;
                            ball.x = Math.max(50 + ball.r, Math.min(canvas.width - 50 - ball.r, ball.x));
                        }
                        if (ball.y - ball.r <= 50 || ball.y + ball.r >= canvas.height - 50) {
                            ball.vy *= -0.9;
                            ball.y = Math.max(50 + ball.r, Math.min(canvas.height - 50 - ball.r, ball.y));
                        }
                        
                        // Ball collision
                        for (let j = i + 1; j < balls.length; j++) {
                            const other = balls[j];
                            const dx = other.x - ball.x;
                            const dy = other.y - ball.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < ball.r + other.r) {
                                // Calculate collision angle
                                const angle = Math.atan2(dy, dx);
                                const sin = Math.sin(angle);
                                const cos = Math.cos(angle);
                                
                                // Rotate velocities
                                const vx1 = ball.vx * cos + ball.vy * sin;
                                const vy1 = ball.vy * cos - ball.vx * sin;
                                const vx2 = other.vx * cos + other.vy * sin;
                                const vy2 = other.vy * cos - other.vx * sin;
                                
                                // Swap velocities
                                ball.vx = vx2 * cos - vy1 * sin;
                                ball.vy = vy1 * cos + vx2 * sin;
                                other.vx = vx1 * cos - vy2 * sin;
                                other.vy = vy2 * cos + vx1 * sin;
                                
                                // Separate balls
                                const overlap = ball.r + other.r - dist;
                                ball.x -= overlap * cos / 2;
                                ball.y -= overlap * sin / 2;
                                other.x += overlap * cos / 2;
                                other.y += overlap * sin / 2;
                                
                                // Update impact info
                                const impactCos = Math.cos(angle);
                                document.getElementById('impact-cosine').textContent = impactCos.toFixed(3);
                                document.getElementById('energy-transfer').textContent = (Math.abs(impactCos) * 100).toFixed(0) + '%';
                            }
                        }
                    }
                    
                    // Draw ball
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                    ctx.fillStyle = ball.color;
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw velocity vector
                    ctx.beginPath();
                    ctx.moveTo(ball.x, ball.y);
                    ctx.lineTo(ball.x + ball.vx * 10, ball.y + ball.vy * 10);
                    ctx.strokeStyle = ball.color;
                    ctx.stroke();
                });
                
                if (isPlaying) {
                    requestAnimationFrame(drawBilliards);
                }
            }
            
            drawBilliards();
            animations.billiard = { draw: drawBilliards, isPlaying };
        }
        
        function resetBilliards() {
            const impactAngle = parseFloat(document.getElementById('impact-angle').value);
            const rad = impactAngle * Math.PI / 180;
            animations.billiard.balls = [
                { x: 200, y: 200, vx: 5 * Math.cos(rad), vy: 5 * Math.sin(rad), r: 20, color: '#ff0000' },
                { x: 600, y: 200, vx: -3, vy: 0, r: 20, color: '#0088ff' }
            ];
            animations.billiard.draw();
        }
        
        function toggleBilliardAnimation() {
            animations.billiard.isPlaying = !animations.billiard.isPlaying;
            if (animations.billiard.isPlaying) animations.billiard.draw();
        }
        
        // Scene 4: Tangent Explosion
        function initTangentDemo() {
            const canvas = document.getElementById('tangent-canvas');
            const ctx = canvas.getContext('2d');
            let animationAngle = 0;
            let isAnimating = false;
            
            function drawTangent() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const angle = isAnimating ? animationAngle : parseFloat(document.getElementById('tangent-angle').value);
                const rad = angle * Math.PI / 180;
                
                // Draw coordinate system
                const centerX = 200;
                const centerY = canvas.height / 2;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(canvas.width, centerY);
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, canvas.height);
                ctx.stroke();
                
                // Draw unit circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw angle
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + 100 * Math.cos(rad), centerY - 100 * Math.sin(rad));
                ctx.stroke();
                
                // Draw functions
                const graphX = 400;
                const graphWidth = canvas.width - graphX - 50;
                
                // Sin curve
                ctx.strokeStyle = '#ff0000';
                ctx.beginPath();
                for (let x = 0; x < graphWidth; x++) {
                    const a = (x / graphWidth) * Math.PI / 2;
                    const y = centerY - 150 * Math.sin(a);
                    if (x === 0) ctx.moveTo(graphX + x, y);
                    else ctx.lineTo(graphX + x, y);
                }
                ctx.stroke();
                
                // Cos curve
                ctx.strokeStyle = '#0088ff';
                ctx.beginPath();
                for (let x = 0; x < graphWidth; x++) {
                    const a = (x / graphWidth) * Math.PI / 2;
                    const y = centerY - 150 * Math.cos(a);
                    if (x === 0) ctx.moveTo(graphX + x, y);
                    else ctx.lineTo(graphX + x, y);
                }
                ctx.stroke();
                
                // Tan curve (with clipping for explosion)
                ctx.strokeStyle = '#ff00ff';
                ctx.beginPath();
                for (let x = 0; x < graphWidth; x++) {
                    const a = (x / graphWidth) * Math.PI / 2;
                    let tanVal = Math.tan(a);
                    tanVal = Math.max(-5, Math.min(5, tanVal)); // Clamp for visibility
                    const y = centerY - 30 * tanVal;
                    if (x === 0) ctx.moveTo(graphX + x, y);
                    else ctx.lineTo(graphX + x, y);
                }
                ctx.stroke();
                
                // Draw current angle marker
                const markerX = graphX + (rad / (Math.PI / 2)) * graphWidth;
                ctx.strokeStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(markerX, 50);
                ctx.lineTo(markerX, canvas.height - 50);
                ctx.stroke();
                
                // Update values
                document.getElementById('tangent-angle-value').textContent = angle.toFixed(0) + '°';
                document.getElementById('sine-value').textContent = Math.sin(rad).toFixed(3);
                document.getElementById('cos-value').textContent = Math.cos(rad).toFixed(3);
                document.getElementById('tan-value').textContent = Math.tan(rad).toFixed(3);
                
                if (isAnimating) {
                    animationAngle = (animationAngle + 0.5) % 90;
                    requestAnimationFrame(drawTangent);
                }
            }
            
            drawTangent();
            animations.tangent = { draw: drawTangent, isAnimating };
            
            document.getElementById('tangent-angle').addEventListener('input', () => {
                if (!isAnimating) drawTangent();
            });
        }
        
        function toggleTangentAnimation() {
            animations.tangent.isAnimating = !animations.tangent.isAnimating;
            if (animations.tangent.isAnimating) animations.tangent.draw();
        }
        
        // Scene 5: Three-Body Problem
        function initGravityDemo() {
            const canvas = document.getElementById('gravity-canvas');
            const ctx = canvas.getContext('2d');
            const G = 0.5;
            let showTrails = false;
            let isPlaying = true;
            
            let bodies = [
                { x: 400, y: 300, vx: 0, vy: -0.5, m: 20, color: '#ff0000', trail: [] },
                { x: 600, y: 300, vx: 0, vy: 0.5, m: 20, color: '#0088ff', trail: [] },
                { x: 500, y: 200, vx: 0.5, vy: 0, m: 20, color: '#00ff00', trail: [] }
            ];
            
            function drawGravity() {
                if (!showTrails) {
                    ctx.fillStyle = 'rgba(15, 15, 15, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                if (isPlaying) {
                    // Update forces
                    bodies.forEach((body, i) => {
                        let fx = 0, fy = 0;
                        
                        bodies.forEach((other, j) => {
                            if (i !== j) {
                                const dx = other.x - body.x;
                                const dy = other.y - body.y;
                                const r2 = dx * dx + dy * dy;
                                const r = Math.sqrt(r2);
                                const f = G * body.m * other.m / r2;
                                
                                fx += f * dx / r;
                                fy += f * dy / r;
                            }
                        });
                        
                        body.vx += fx / body.m;
                        body.vy += fy / body.m;
                    });
                    
                    // Update positions
                    bodies.forEach(body => {
                        body.x += body.vx;
                        body.y += body.vy;
                        
                        // Add to trail
                        body.trail.push({ x: body.x, y: body.y });
                        if (body.trail.length > 200) body.trail.shift();
                    });
                }
                
                // Draw trails
                if (showTrails) {
                    bodies.forEach(body => {
                        ctx.strokeStyle = body.color;
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        body.trail.forEach((point, i) => {
                            if (i === 0) ctx.moveTo(point.x, point.y);
                            else ctx.lineTo(point.x, point.y);
                        });
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    });
                }
                
                // Draw bodies
                bodies.forEach(body => {
                    ctx.beginPath();
                    ctx.arc(body.x, body.y, body.m, 0, Math.PI * 2);
                    ctx.fillStyle = body.color;
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // Draw angle indicators
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < bodies.length; i++) {
                    for (let j = i + 1; j < bodies.length; j++) {
                        ctx.beginPath();
                        ctx.moveTo(bodies[i].x, bodies[i].y);
                        ctx.lineTo(bodies[j].x, bodies[j].y);
                        ctx.stroke();
                    }
                }
                
                if (isPlaying) {
                    requestAnimationFrame(drawGravity);
                }
            }
            
            drawGravity();
            animations.gravity = { draw: drawGravity, isPlaying, showTrails };
        }
        
        function resetGravity() {
            animations.gravity.bodies = [
                { x: 400, y: 300, vx: 0, vy: -0.5, m: 20, color: '#ff0000', trail: [] },
                { x: 600, y: 300, vx: 0, vy: 0.5, m: 20, color: '#0088ff', trail: [] },
                { x: 500, y: 200, vx: 0.5, vy: 0, m: 20, color: '#00ff00', trail: [] }
            ];
            animations.gravity.draw();
        }
        
        function toggleGravityAnimation() {
            animations.gravity.isPlaying = !animations.gravity.isPlaying;
            if (animations.gravity.isPlaying) animations.gravity.draw();
        }
        
        function addTrails() {
            animations.gravity.showTrails = !animations.gravity.showTrails;
        }
        
        // Scene 6: Pi Calculation
        function initPiDemo() {
            const canvas = document.getElementById('pi-canvas');
            const ctx = canvas.getContext('2d');
            let collisions = 0;
            let isCalculating = false;
            
            let block1 = { x: 200, vx: 0, m: 1, w: 50 };
            let block2 = { x: 400, vx: -1, m: 100, w: 100 };
            
            function drawPi() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw floor
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - 50);
                ctx.lineTo(canvas.width, canvas.height - 50);
                ctx.stroke();
                
                // Draw wall
                ctx.fillStyle = '#333333';
                ctx.fillRect(0, 100, 20, canvas.height - 150);
                
                // Update physics
                if (isCalculating) {
                    // Block collision
                    if (block1.x + block1.w >= block2.x) {
                        const v1 = block1.vx;
                        const v2 = block2.vx;
                        const m1 = block1.m;
                        const m2 = block2.m;
                        
                        block1.vx = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2);
                        block2.vx = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2);
                        collisions++;
                    }
                    
                    // Wall collision
                    if (block1.x <= 20) {
                        block1.vx = Math.abs(block1.vx);
                        collisions++;
                    }
                    
                    // Update positions
                    block1.x += block1.vx * 5;
                    block2.x += block2.vx * 5;
                }
                
                // Draw blocks
                const groundY = canvas.height - 50;
                
                // Block 1
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(block1.x, groundY - block1.w, block1.w, block1.w);
                ctx.strokeStyle = '#ffffff';
                ctx.strokeRect(block1.x, groundY - block1.w, block1.w, block1.w);
                
                // Block 2
                ctx.fillStyle = '#0088ff';
                ctx.fillRect(block2.x, groundY - block2.w, block2.w, block2.w);
                ctx.strokeStyle = '#ffffff';
                ctx.strokeRect(block2.x, groundY - block2.w, block2.w, block2.w);
                
                // Draw velocities
                ctx.font = '16px monospace';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`v1: ${block1.vx.toFixed(2)}`, block1.x, groundY - block1.w - 10);
                ctx.fillText(`v2: ${block2.vx.toFixed(2)}`, block2.x, groundY - block2.w - 10);
                
                // Update info
                document.getElementById('collision-count').textContent = collisions;
                const piApprox = collisions / Math.pow(10, Math.floor(Math.log10(block2.m) / 2));
                document.getElementById('pi-approximation').textContent = piApprox.toFixed(6);
                document.getElementById('pi-error').textContent = (Math.abs(piApprox - Math.PI) / Math.PI * 100).toFixed(2) + '%';
                
                if (isCalculating && Math.abs(block2.vx) > 0.001) {
                    requestAnimationFrame(drawPi);
                } else {
                    isCalculating = false;
                }
            }
            
            drawPi();
            animations.pi = { draw: drawPi, isCalculating };
        }
        
        function startPiCalculation() {
            animations.pi.isCalculating = true;
            animations.pi.draw();
        }
        
        function resetPiCalculation() {
            const power = parseInt(document.getElementById('mass-ratio').value);
            animations.pi.collisions = 0;
            animations.pi.block1 = { x: 200, vx: 0, m: 1, w: 50 };
            animations.pi.block2 = { x: 400, vx: -1, m: Math.pow(100, power), w: 100 };
            animations.pi.isCalculating = false;
            document.getElementById('mass-power').textContent = power * 2;
            animations.pi.draw();
        }
        
        // Scene 7: Prime Spiral
        function initPrimeDemo() {
            const canvas = document.getElementById('prime-canvas');
            const ctx = canvas.getContext('2d');
            let zoom = 5;
            let viewMode = 'spiral'; // 'spiral' or 'constellation'
            let primes = new Set();
            let isAnimating = false;
            let currentNumber = 1;
            
            // Sieve of Eratosthenes
            function generatePrimes(max) {
                const sieve = new Array(max + 1).fill(true);
                sieve[0] = sieve[1] = false;
                
                for (let i = 2; i * i <= max; i++) {
                    if (sieve[i]) {
                        for (let j = i * i; j <= max; j += i) {
                            sieve[j] = false;
                        }
                    }
                }
                
                for (let i = 2; i <= max; i++) {
                    if (sieve[i]) primes.add(i);
                }
            }
            
            generatePrimes(10000);
            
            function drawPrimes() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = zoom;
                
                if (viewMode === 'spiral') {
                    // Ulam spiral
                    let x = 0, y = 0;
                    let dx = 1, dy = 0;
                    let segmentLength = 1;
                    let segmentPassed = 0;
                    
                    for (let n = 1; n <= (isAnimating ? currentNumber : 2500); n++) {
                        const screenX = centerX + x * scale;
                        const screenY = centerY + y * scale;
                        
                        if (primes.has(n)) {
                            ctx.fillStyle = '#ff00ff';
                            ctx.fillRect(screenX - scale/2, screenY - scale/2, scale, scale);
                        } else {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                            ctx.fillRect(screenX - scale/2, screenY - scale/2, scale, scale);
                        }
                        
                        // Move to next position
                        x += dx;
                        y += dy;
                        segmentPassed++;
                        
                        if (segmentPassed === segmentLength) {
                            segmentPassed = 0;
                            
                            // Rotate
                            const temp = dx;
                            dx = -dy;
                            dy = temp;
                            
                            if (dy === 0) {
                                segmentLength++;
                            }
                        }
                    }
                } else {
                    // Prime constellation view
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    
                    // Draw polar grid
                    for (let r = 50; r < canvas.width/2; r += 50) {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Plot primes in polar coordinates
                    primes.forEach(p => {
                        if (p > (isAnimating ? currentNumber : 2000)) return;
                        
                        const angle = p;
                        const radius = Math.sqrt(p) * scale;
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fillStyle = `hsl(${(p * 137.5) % 360}, 70%, 60%)`;
                        ctx.fill();
                    });
                }
                
                // Update info
                const primeCount = [...primes].filter(p => p <= (isAnimating ? currentNumber : 2500)).length;
                document.getElementById('prime-count').textContent = primeCount;
                document.getElementById('prime-density').textContent = (primeCount / (isAnimating ? currentNumber : 2500) * 100).toFixed(1) + '%';
                
                if (isAnimating) {
                    currentNumber += 10;
                    if (currentNumber < 2500) {
                        requestAnimationFrame(drawPrimes);
                    } else {
                        isAnimating = false;
                    }
                }
            }
            
            drawPrimes();
            animations.primes = { draw: drawPrimes, isAnimating };
            
            document.getElementById('prime-zoom').addEventListener('input', (e) => {
                zoom = parseInt(e.target.value);
                drawPrimes();
            });
        }
        
        function togglePrimeAnimation() {
            animations.primes.currentNumber = 1;
            animations.primes.isAnimating = !animations.primes.isAnimating;
            if (animations.primes.isAnimating) animations.primes.draw();
        }
        
        function switchPrimeView() {
            animations.primes.viewMode = animations.primes.viewMode === 'spiral' ? 'constellation' : 'spiral';
            animations.primes.draw();
        }
        
        // Scene 8: Flocking
        function initFlockDemo() {
            const canvas = document.getElementById('flock-canvas');
            const ctx = canvas.getContext('2d');
            let boids = [];
            let isPlaying = true;
            
            class Boid {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.ax = 0;
                    this.ay = 0;
                    this.maxSpeed = 2;
                    this.maxForce = 0.05;
                }
                
                flock(boids) {
                    const perception = 50;
                    const separation = this.separate(boids, perception);
                    const alignment = this.align(boids, perception);
                    const cohesion = this.cohere(boids, perception);
                    
                    // Weight forces
                    separation.x *= 1.5;
                    separation.y *= 1.5;
                    alignment.x *= 1.0;
                    alignment.y *= 1.0;
                    cohesion.x *= 1.0;
                    cohesion.y *= 1.0;
                    
                    this.ax = separation.x + alignment.x + cohesion.x;
                    this.ay = separation.y + alignment.y + cohesion.y;
                }
                
                separate(boids, perception) {
                    let steer = { x: 0, y: 0 };
                    let count = 0;
                    
                    boids.forEach(other => {
                        const d = Math.sqrt((this.x - other.x)**2 + (this.y - other.y)**2);
                        if (d > 0 && d < perception) {
                            const diff = {
                                x: (this.x - other.x) / d,
                                y: (this.y - other.y) / d
                            };
                            steer.x += diff.x;
                            steer.y += diff.y;
                            count++;
                        }
                    });
                    
                    if (count > 0) {
                        steer.x /= count;
                        steer.y /= count;
                    }
                    
                    return steer;
                }
                
                align(boids, perception) {
                    let steer = { x: 0, y: 0 };
                    let count = 0;
                    
                    boids.forEach(other => {
                        const d = Math.sqrt((this.x - other.x)**2 + (this.y - other.y)**2);
                        if (d > 0 && d < perception) {
                            steer.x += other.vx;
                            steer.y += other.vy;
                            count++;
                        }
                    });
                    
                    if (count > 0) {
                        steer.x = (steer.x / count - this.vx) * 0.1;
                        steer.y = (steer.y / count - this.vy) * 0.1;
                    }
                    
                    return steer;
                }
                
                cohere(boids, perception) {
                    let center = { x: 0, y: 0 };
                    let count = 0;
                    
                    boids.forEach(other => {
                        const d = Math.sqrt((this.x - other.x)**2 + (this.y - other.y)**2);
                        if (d > 0 && d < perception) {
                            center.x += other.x;
                            center.y += other.y;
                            count++;
                        }
                    });
                    
                    if (count > 0) {
                        center.x /= count;
                        center.y /= count;
                        return {
                            x: (center.x - this.x) * 0.01,
                            y: (center.y - this.y) * 0.01
                        };
                    }
                    
                    return { x: 0, y: 0 };
                }
                
                update() {
                    this.vx += this.ax;
                    this.vy += this.ay;
                    
                    // Limit speed
                    const speed = Math.sqrt(this.vx**2 + this.vy**2);
                    if (speed > this.maxSpeed) {
                        this.vx = (this.vx / speed) * this.maxSpeed;
                        this.vy = (this.vy / speed) * this.maxSpeed;
                    }
                    
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Wrap around edges
                    if (this.x < 0) this.x = canvas.width;
                    if (this.x > canvas.width) this.x = 0;
                    if (this.y < 0) this.y = canvas.height;
                    if (this.y > canvas.height) this.y = 0;
                    
                    this.ax = 0;
                    this.ay = 0;
                }
                
                draw(ctx) {
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(-5, -5);
                    ctx.lineTo(-5, 5);
                    ctx.closePath();
                    
                    const speed = Math.sqrt(this.vx**2 + this.vy**2);
                    ctx.fillStyle = `hsl(${speed * 60}, 70%, 60%)`;
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            
            // Initialize flock
            for (let i = 0; i < 50; i++) {
                boids.push(new Boid(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                ));
            }
            
            function drawFlock() {
                ctx.fillStyle = 'rgba(15, 15, 15, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (isPlaying) {
                    boids.forEach(boid => {
                        boid.flock(boids);
                        boid.update();
                    });
                }
                
                boids.forEach(boid => boid.draw(ctx));
                
                // Calculate average alignment
                let avgVx = 0, avgVy = 0;
                boids.forEach(boid => {
                    avgVx += boid.vx;
                    avgVy += boid.vy;
                });
                avgVx /= boids.length;
                avgVy /= boids.length;
                const alignment = Math.sqrt(avgVx**2 + avgVy**2) / 2;
                
                document.getElementById('boid-count').textContent = boids.length;
                document.getElementById('alignment').textContent = alignment.toFixed(2);
                
                if (isPlaying) {
                    requestAnimationFrame(drawFlock);
                }
            }
            
            drawFlock();
            animations.flock = { draw: drawFlock, isPlaying, boids };
            
            document.getElementById('coherence').addEventListener('input', (e) => {
                const coherence = parseInt(e.target.value) / 100;
                animations.flock.boids.forEach(boid => {
                    boid.maxForce = 0.02 + coherence * 0.08;
                });
            });
        }
        
        function resetFlock() {
            animations.flock.boids = [];
            for (let i = 0; i < 50; i++) {
                animations.flock.boids.push({
                    x: Math.random() * 1200,
                    y: Math.random() * 600,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    ax: 0,
                    ay: 0,
                    maxSpeed: 2,
                    maxForce: 0.05
                });
            }
        }
        
        function toggleFlockAnimation() {
            animations.flock.isPlaying = !animations.flock.isPlaying;
            if (animations.flock.isPlaying) animations.flock.draw();
        }
        
        // Scene 9: SEP Framework
        function initSEPDemo() {
            const canvas = document.getElementById('sep-canvas');
            const ctx = canvas.getContext('2d');
            const gridSize = 8;
            let quantumState = new Array(64).fill(0);
            let coherence = 1.0;
            let ruptures = [];
            
            function drawSEP() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw 64-bit state grid
                const cellSize = 40;
                const startX = 50;
                const startY = 50;
                
                for (let i = 0; i < 64; i++) {
                    const row = Math.floor(i / 8);
                    const col = i % 8;
                    const x = startX + col * (cellSize + 5);
                    const y = startY + row * (cellSize + 5);
                    
                    // Cell background
                    const value = quantumState[i];
                    ctx.fillStyle = `rgba(102, 126, 234, ${Math.abs(value)})`;
                    ctx.fillRect(x, y, cellSize, cellSize);
                    
                    // Cell border
                    ctx.strokeStyle = ruptures.includes(i) ? '#ff0000' : '#ffffff';
                    ctx.lineWidth = ruptures.includes(i) ? 3 : 1;
                    ctx.strokeRect(x, y, cellSize, cellSize);
                    
                    // Bit value
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(value > 0.5 ? '1' : '0', x + cellSize/2, y + cellSize/2 + 4);
                }
                
                // Draw frequency spectrum
                const spectrumX = 500;
                const spectrumWidth = 600;
                const spectrumHeight = 200;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.strokeRect(spectrumX, startY, spectrumWidth, spectrumHeight);
                
                // Simulate frequency bars
                for (let i = 0; i < 32; i++) {
                    const height = Math.random() * spectrumHeight * coherence;
                    const x = spectrumX + i * (spectrumWidth / 32);
                    
                    ctx.fillStyle = `hsl(${240 + i * 2}, 70%, 60%)`;
                    ctx.fillRect(x, startY + spectrumHeight - height, spectrumWidth/32 - 2, height);
                }
                
                // Draw coherence visualization
                const coherenceY = startY + spectrumHeight + 50;
                ctx.beginPath();
                ctx.arc(spectrumX + spectrumWidth/2, coherenceY + 100, 80, 0, Math.PI * 2);
                ctx.strokeStyle = coherence > 0.5 ? '#00ff00' : '#ff0000';
                ctx.lineWidth = 5;
                ctx.stroke();
                
                // Coherence waves
                for (let r = 20; r < 80; r += 20) {
                    ctx.beginPath();
                    ctx.arc(spectrumX + spectrumWidth/2, coherenceY + 100, r, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(102, 126, 234, ${coherence * (1 - r/80)})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Update state display
                const stateString = quantumState.map(v => v > 0.5 ? '1' : '0').join('');
                document.getElementById('state-vector').textContent = `|${stateString.substring(0, 8)}...${stateString.substring(56)}⟩`;
                document.getElementById('coherence-level').textContent = coherence.toFixed(3);
                document.getElementById('rupture-count').textContent = ruptures.length;
            }
            
            drawSEP();
            animations.sep = { draw: drawSEP, quantumState, coherence, ruptures };
        }
        
        function runQBSA() {
            // Simulate QBSA rupture detection
            animations.sep.ruptures = [];
            for (let i = 0; i < 64; i++) {
                if (Math.random() < 0.1) {
                    animations.sep.ruptures.push(i);
                    animations.sep.quantumState[i] = Math.random();
                }
            }
            animations.sep.coherence = Math.max(0, animations.sep.coherence - 0.1);
            animations.sep.draw();
        }
        
        function runQFH() {
            // Simulate QFH frequency analysis
            animations.sep.coherence = 1.0;
            animations.sep.ruptures = [];
            for (let i = 0; i < 64; i++) {
                animations.sep.quantumState[i] = Math.sin(i * 0.5) * 0.5 + 0.5;
            }
            animations.sep.draw();
        }
        
        function resetSEP() {
            animations.sep.quantumState = new Array(64).fill(0);
            animations.sep.coherence = 1.0;
            animations.sep.ruptures = [];
            animations.sep.draw();
        }
        
        // Scene 10: Fluid Dynamics
        function initFluidDemo() {
            const canvas = document.getElementById('fluid-canvas');
            const ctx = canvas.getContext('2d');
            const gridSize = 100;
            let particles = [];
            let vortices = [];
            let isPlaying = true;
            
            class Particle {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.vx = 0;
                    this.vy = 0;
                    this.life = 1;
                }
                
                update(vortices) {
                    // Apply vortex forces
                    vortices.forEach(vortex => {
                        const dx = this.x - vortex.x;
                        const dy = this.y - vortex.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < vortex.radius && dist > 5) {
                            const force = vortex.strength / dist;
                            this.vx += -dy * force * 0.01;
                            this.vy += dx * force * 0.01;
                        }
                    });
                    
                    // Apply viscosity
                    this.vx *= 0.99;
                    this.vy *= 0.99;
                    
                    // Update position
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Boundary conditions
                    if (this.x < 0 || this.x > canvas.width || 
                        this.y < 0 || this.y > canvas.height) {
                        this.life = 0;
                    }
                }
                
                draw(ctx) {
                    const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                    ctx.fillStyle = `hsla(${200 + speed * 20}, 70%, 60%, ${this.life})`;
                    ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
                }
            }
            
            // Initialize with vortices
            vortices.push({ x: 300, y: 300, radius: 100, strength: 50 });
            vortices.push({ x: 900, y: 300, radius: 100, strength: -50 });
            
            function drawFluid() {
                ctx.fillStyle = 'rgba(15, 15, 15, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (isPlaying) {
                    // Add new particles
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height
                        ));
                    }
                    
                    // Update particles
                    particles = particles.filter(p => {
                        p.update(vortices);
                        return p.life > 0;
                    });
                    
                    // Limit particle count
                    if (particles.length > 1000) {
                        particles = particles.slice(-1000);
                    }
                }
                
                // Draw vortices
                vortices.forEach(vortex => {
                    ctx.strokeStyle = vortex.strength > 0 ? 'rgba(255, 0, 0, 0.3)' : 'rgba(0, 136, 255, 0.3)';
                    ctx.lineWidth = 2;
                    for (let r = 20; r < vortex.radius; r += 20) {
                        ctx.beginPath();
                        ctx.arc(vortex.x, vortex.y, r, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                });
                
                // Draw particles
                particles.forEach(p => p.draw(ctx));
                
                // Calculate vorticity
                const avgVorticity = vortices.reduce((sum, v) => sum + Math.abs(v.strength), 0) / vortices.length;
                document.getElementById('vorticity').textContent = avgVorticity.toFixed(2);
                
                if (isPlaying) {
                    requestAnimationFrame(drawFluid);
                }
            }
            
            drawFluid();
            animations.fluid = { draw: drawFluid, isPlaying, particles, vortices };
        }
        
        function resetFluid() {
            animations.fluid.particles = [];
            animations.fluid.vortices = [
                { x: 300, y: 300, radius: 100, strength: 50 },
                { x: 900, y: 300, radius: 100, strength: -50 }
            ];
            animations.fluid.draw();
        }
        
        function toggleFluidAnimation() {
            animations.fluid.isPlaying = !animations.fluid.isPlaying;
            if (animations.fluid.isPlaying) animations.fluid.draw();
        }
        
        function addVortex() {
            animations.fluid.vortices.push({
                x: Math.random() * 1200,
                y: Math.random() * 600,
                radius: 50 + Math.random() * 100,
                strength: (Math.random() - 0.5) * 100
            });
        }
        
        // Scene 11: Black-Scholes
        function initOptionsDemo() {
            const canvas = document.getElementById('options-canvas');
            const ctx = canvas.getContext('2d');
            
            function drawOptions() {
                ctx.fillStyle = '#0f0f0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const S0 = 100; // Current price
                const K = 100;  // Strike price
                const r = 0.05; // Risk-free rate
                const T = 1;    // Time to maturity
                const sigma = parseInt(document.getElementById('volatility').value) / 100;
                
                // Draw option price surface
                const gridX = 50;
                const gridY = 50;
                const gridWidth = 500;
                const gridHeight = 400;
                
                // Price grid
                for (let i = 0; i <= 20; i++) {
                    for (let j = 0; j <= 20; j++) {
                        const S = 50 + i * 5;
                        const t = j * 0.05;
                        
                        // Simplified Black-Scholes calculation
                        const d1 = (Math.log(S/K) + (r + sigma*sigma/2) * (T-t)) / (sigma * Math.sqrt(T-t));
                        const price = S * 0.5 * (1 + erf(d1/Math.sqrt(2))) - K * Math.exp(-r*(T-t)) * 0.5 * (1 + erf((d1 - sigma*Math.sqrt(T-t))/Math.sqrt(2)));
                        
                        const x = gridX + i * (gridWidth/20);
                        const y = gridY + j * (gridHeight/20);
                        const color = Math.min(255, price * 2.55);
                        
                        ctx.fillStyle = `rgb(${color}, ${color/2}, ${255-color})`;
                        ctx.fillRect(x, y, gridWidth/20, gridHeight/20);
                    }
                }
                
                // Draw axes
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(gridX, gridY + gridHeight);
                ctx.lineTo(gridX + gridWidth, gridY + gridHeight);
                ctx.moveTo(gridX, gridY);
                ctx.lineTo(gridX, gridY + gridHeight);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#ffffff';
                ctx.font = '14px monospace';
                ctx.fillText('Stock Price', gridX + gridWidth/2 - 40, gridY + gridHeight + 30);
                ctx.save();
                ctx.translate(gridX - 30, gridY + gridHeight/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText('Time to Maturity', 0, 0);
                ctx.restore();
                
                // SEP comparison visualization
                const compX = 650;
                const compWidth = 500;
                const barHeight = 50;
                
                // Traditional method
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(compX, gridY, compWidth * 0.8, barHeight);
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px monospace';
                ctx.fillText('Traditional PDE: 100ms', compX + 10, gridY + 30);
                
                // SEP method
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(compX, gridY + 80, compWidth * 0.3, barHeight);
                ctx.fillText('SEP Method: 37ms', compX + 10, gridY + 110);
                
                // Efficiency gain
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(compX + compWidth * 0.3, gridY + 130);
                ctx.lineTo(compX + compWidth * 0.8, gridY + 50);
                ctx.stroke();
                
                ctx.fillStyle = '#ffff00';
                ctx.font = '24px monospace';
                ctx.fillText('2.7x Speedup!', compX + compWidth * 0.5, gridY + 200);
                
                // Update volatility display
                document.getElementById('vol-value').textContent = (sigma * 100).toFixed(0) + '%';
                document.getElementById('trad-time').textContent = '100.00ms';
                document.getElementById('sep-time').textContent = '37.04ms';
                document.getElementById('speedup').textContent = '2.7x';
            }
            
            // Error function approximation
            function erf(x) {
                const a1 =  0.254829592;
                const a2 = -0.284496736;
                const a3 =  1.421413741;
                const a4 = -1.453152027;
                const a5 =  1.061405429;
                const p  =  0.3275911;
                
                const sign = x >= 0 ? 1 : -1;
                x = Math.abs(x);
                
                const t = 1.0 / (1.0 + p * x);
                const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                
                return sign * y;
            }
            
            drawOptions();
            animations.options = { draw: drawOptions };
            
            document.getElementById('volatility').addEventListener('input', drawOptions);
        }
        
        function calculateOptions() {
            // Simulate calculation with animation
            const startTime = Date.now();
            setTimeout(() => {
                const elapsed = Date.now() - startTime;
                document.getElementById('trad-time').textContent = (100 + Math.random() * 20).toFixed(2) + 'ms';
                document.getElementById('sep-time').textContent = (30 + Math.random() * 10).toFixed(2) + 'ms';
                const speedup = 100 / 35;
                document.getElementById('speedup').textContent = speedup.toFixed(1) + 'x';
                animations.options.draw();
            }, 500);
        }
        
        // Scene 12: Meta Visualization
        function initMetaDemo() {
            const canvas = document.getElementById('meta-canvas');
            const ctx = canvas.getContext('2d');
            let mode = 0;
            let time = 0;
            let isPlaying = true;
            
            function drawMeta() {
                ctx.fillStyle = 'rgba(10, 10, 10, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Central rotating angles
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(time * 0.01);
                
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const radius = 150 + Math.sin(time * 0.05 + i) * 50;
                    
                    ctx.strokeStyle = `hsl(${i * 30}, 70%, 60%)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                    ctx.stroke();
                    
                    // Node at end
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * radius, Math.sin(angle) * radius, 5, 0, Math.PI * 2);
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.fill();
                }
                ctx.restore();
                
                // Boundary circles
                for (let r = 100; r < 400; r += 100) {
                    ctx.strokeStyle = `rgba(102, 126, 234, ${0.3 - r/1500})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r + Math.sin(time * 0.02) * 20, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Prime constellation overlay
                const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
                primes.forEach((p, i) => {
                    const angle = p * time * 0.001;
                    const radius = 200 + i * 15;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff00ff';
                    ctx.fill();
                });
                
                // Coherence waves
                const waveCount = 5;
                for (let i = 0; i < waveCount; i++) {
                    const phase = time * 0.02 + i * Math.PI / waveCount;
                    const amp = 100;
                    
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 - i/10})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let x = 0; x < canvas.width; x += 5) {
                        const y = centerY + Math.sin((x - centerX) * 0.01 + phase) * amp * (1 - Math.abs(x - centerX) / centerX);
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // SEP Framework text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 48px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('SEP', centerX, centerY);
                
                ctx.font = '16px monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillText('Sine Emergent Perspective', centerX, centerY + 30);
                
                // Integration percentage
                const integration = Math.min(100, (time / 10) % 100);
                document.getElementById('integration').textContent = integration.toFixed(0) + '%';
                document.getElementById('framework-status').textContent = 
                    integration < 25 ? 'Initializing...' :
                    integration < 50 ? 'Loading Quantum States...' :
                    integration < 75 ? 'Establishing Coherence...' :
                    'Framework Active';
                
                if (isPlaying) {
                    time++;
                    requestAnimationFrame(drawMeta);
                }
            }
            
            drawMeta();
            animations.meta = { draw: drawMeta, isPlaying, mode };
        }
        
        function toggleMetaAnimation() {
            animations.meta.isPlaying = !animations.meta.isPlaying;
            if (animations.meta.isPlaying) animations.meta.draw();
        }
        
        function cycleMetaMode() {
            animations.meta.mode = (animations.meta.mode + 1) % 3;
        }
        
        // Initialize all demos
        window.onload = function() {
            initWaveDemo();
            initAngleDemo();
            initBilliardDemo();
            initTangentDemo();
            initGravityDemo();
            initPiDemo();
            initPrimeDemo();
            initFlockDemo();
            initSEPDemo();
            initFluidDemo();
            initOptionsDemo();
            initMetaDemo();
        };
    </script>
</body>
</html>